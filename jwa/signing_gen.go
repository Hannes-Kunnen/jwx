// Code generated by tools/cmd/genjwa/main.go. DO NOT EDIT.

package jwa

import (
	"fmt"
	"sort"
	"sync"
)

// SigningAlgorithm represents the various algorithms that can be used to sign a payload.
// These are described in https://tools.ietf.org/html/rfc7518#section-3.1.
// Keep in mind that NoSignature is not a part of this as no signing can be performed with this value
type SigningAlgorithm string

// Supported values for SigningAlgorithm
const (
	ES256  SigningAlgorithm = "ES256"  // ECDSA using P-256 and SHA-256
	ES256K SigningAlgorithm = "ES256K" // ECDSA using secp256k1 and SHA-256
	ES384  SigningAlgorithm = "ES384"  // ECDSA using P-384 and SHA-384
	ES512  SigningAlgorithm = "ES512"  // ECDSA using P-521 and SHA-512
	EdDSA  SigningAlgorithm = "EdDSA"  // EdDSA signature algorithms
	HS256  SigningAlgorithm = "HS256"  // HMAC using SHA-256
	HS384  SigningAlgorithm = "HS384"  // HMAC using SHA-384
	HS512  SigningAlgorithm = "HS512"  // HMAC using SHA-512
	PS256  SigningAlgorithm = "PS256"  // RSASSA-PSS using SHA256 and MGF1-SHA256
	PS384  SigningAlgorithm = "PS384"  // RSASSA-PSS using SHA384 and MGF1-SHA384
	PS512  SigningAlgorithm = "PS512"  // RSASSA-PSS using SHA512 and MGF1-SHA512
	RS256  SigningAlgorithm = "RS256"  // RSASSA-PKCS-v1.5 using SHA-256
	RS384  SigningAlgorithm = "RS384"  // RSASSA-PKCS-v1.5 using SHA-384
	RS512  SigningAlgorithm = "RS512"  // RSASSA-PKCS-v1.5 using SHA-512
)

var muSigningAlgorithms sync.RWMutex
var allSigningAlgorithms map[SigningAlgorithm]struct{}
var listSigningAlgorithm []SigningAlgorithm

func init() {
	muSigningAlgorithms.Lock()
	defer muSigningAlgorithms.Unlock()
	muSignatureAlgorithms.Lock()
	defer muSignatureAlgorithms.Unlock()
	allSigningAlgorithms = make(map[SigningAlgorithm]struct{})
	allSigningAlgorithms[ES256] = struct{}{}
	allSigningAlgorithms[ES256K] = struct{}{}
	allSigningAlgorithms[ES384] = struct{}{}
	allSigningAlgorithms[ES512] = struct{}{}
	allSigningAlgorithms[EdDSA] = struct{}{}
	allSigningAlgorithms[HS256] = struct{}{}
	allSigningAlgorithms[HS384] = struct{}{}
	allSigningAlgorithms[HS512] = struct{}{}
	allSigningAlgorithms[PS256] = struct{}{}
	allSigningAlgorithms[PS384] = struct{}{}
	allSigningAlgorithms[PS512] = struct{}{}
	allSigningAlgorithms[RS256] = struct{}{}
	allSigningAlgorithms[RS384] = struct{}{}
	allSigningAlgorithms[RS512] = struct{}{}
	rebuildSigningAlgorithm()
	rebuildSignatureAlgorithm()
}

// RegisterSigningAlgorithm registers a new SigningAlgorithm so that the jwx can properly handle the new value.
// Keep in mind that this is linked to will also add a new SignatureAlgorithm as these are linked.
// Duplicates will silently be ignored
func RegisterSigningAlgorithm(v SigningAlgorithm) {
	muSigningAlgorithms.Lock()
	defer muSigningAlgorithms.Unlock()
	muSignatureAlgorithms.Lock()
	defer muSignatureAlgorithms.Unlock()
	if _, ok := allSigningAlgorithms[v]; !ok {
		allSigningAlgorithms[v] = struct{}{}
		rebuildSigningAlgorithm()
		rebuildSignatureAlgorithm()
	}
}

// UnregisterSigningAlgorithm unregisters a SigningAlgorithm from its known database.
// Keep in mind that this will also remove the linked SignatureAlgorithm.
// Non-existent entries will silently be ignored
func UnregisterSigningAlgorithm(v SigningAlgorithm) {
	muSigningAlgorithms.Lock()
	defer muSigningAlgorithms.Unlock()
	muSignatureAlgorithms.Lock()
	defer muSignatureAlgorithms.Unlock()
	if _, ok := allSigningAlgorithms[v]; ok {
		delete(allSigningAlgorithms, v)
		rebuildSigningAlgorithm()
		rebuildSignatureAlgorithm()
	}
}

func rebuildSigningAlgorithm() {
	listSigningAlgorithm = make([]SigningAlgorithm, 0, len(allSigningAlgorithms))
	for v := range allSigningAlgorithms {
		listSigningAlgorithm = append(listSigningAlgorithm, v)
	}
	sort.Slice(listSigningAlgorithm, func(i, j int) bool {
		return string(listSigningAlgorithm[i]) < string(listSigningAlgorithm[j])
	})
}

// SigningAlgorithms returns a list of all available values for SigningAlgorithm
func SigningAlgorithms() []SigningAlgorithm {
	muSigningAlgorithms.RLock()
	defer muSigningAlgorithms.RUnlock()
	return listSigningAlgorithm
}

// Accept is used when conversion from values given by
// outside sources (such as JSON payloads) is required
func (v *SigningAlgorithm) Accept(value interface{}) error {
	var tmp SigningAlgorithm
	if x, ok := value.(SigningAlgorithm); ok {
		tmp = x
	} else {
		var s string
		switch x := value.(type) {
		case fmt.Stringer:
			s = x.String()
		case string:
			s = x
		default:
			return fmt.Errorf(`invalid type for jwa.SigningAlgorithm: %T`, value)
		}
		tmp = SigningAlgorithm(s)
	}
	if _, ok := allSigningAlgorithms[tmp]; !ok {
		return fmt.Errorf(`invalid jwa.SigningAlgorithm value`)
	}

	*v = tmp
	return nil
}

// String returns the string representation of a SigningAlgorithm
func (v SigningAlgorithm) String() string {
	return string(v)
}

// isSignatureAlgorithm is just added so it would qualify as a SignatureAlgorithm.
func (v SigningAlgorithm) isSignatureAlgorithm() {}

// IsSymmetric returns true if the algorithm is a symmetric type
func (v SigningAlgorithm) IsSymmetric() bool {
	switch v {
	case HS256, HS384, HS512:
		return true
	}
	return false
}
